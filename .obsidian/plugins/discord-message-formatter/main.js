/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DiscordFormatter
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/utils.ts
var CouldNotParseError = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, CouldNotParseError.prototype);
  }
};
var EmptyMessageError = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, EmptyMessageError.prototype);
  }
};
function parseMessageAttachments(messageAccessoryElem) {
  if (messageAccessoryElem.nodeName != "DIV" || !/message-accessories/.test(messageAccessoryElem.id)) {
    throw new CouldNotParseError('messageAccessoryElem not <div id="message-accessories...">');
  }
  const messageAccessoryImages = Array.from(messageAccessoryElem.querySelectorAll("img"));
  return messageAccessoryImages.map((img) => {
    return img.src;
  });
}

// src/TextRuns.ts
function textRunFactory(elem) {
  var _a;
  if (elem.className.contains("emojiContainer")) {
    const imgElem = elem.children[0];
    if (!imgElem) {
      throw new CouldNotParseError("parseMessageText: No img element found in span.emojiContainer");
    }
    if (/^:.+:$/.test(imgElem.alt)) {
      return new TextRunCustomEmoji(imgElem.src);
    } else {
      return new TextRunEmoji(imgElem.alt);
    }
  }
  const textContent = elem.textContent;
  if (!textContent) {
    throw new EmptyMessageError("textRunFactory: Message run contains neither text content nor emoji; probably a system message?");
  }
  switch (elem.nodeName) {
    case "EM": {
      return new TextRunItalics(textContent);
      break;
    }
    case "STRONG": {
      return new TextRunBold(textContent);
      break;
    }
    case "U": {
      return new TextRunUnderline(textContent);
      break;
    }
    case "S": {
      return new TextRunStrikethrough(textContent);
      break;
    }
    case "H1":
    case "H2":
    case "H3": {
      return new TextRunHeading(textContent);
      break;
    }
    default: {
      if (elem.className.contains("blockquote")) {
        return new TextRunQuote(textContent);
      } else if (elem.className.contains("timestamp") && ((_a = elem == null ? void 0 : elem.firstChild) == null ? void 0 : _a.nodeName) == "TIME") {
        return new TextRunEdited(textContent);
      } else {
        return new TextRunDefault(textContent);
      }
    }
  }
}
var TextRun = class {
  constructor(content) {
    this.content = content;
  }
};
var TextRunDefault = class extends TextRun {
  toMarkdown(settings) {
    return `${this.content}`;
  }
};
var TextRunItalics = class extends TextRun {
  toMarkdown(settings) {
    return `*${this.content}*`;
  }
};
var TextRunBold = class extends TextRun {
  toMarkdown(settings) {
    return `**${this.content}**`;
  }
};
var TextRunUnderline = class extends TextRun {
  toMarkdown(settings) {
    return `<u>${this.content}</u>`;
  }
};
var TextRunStrikethrough = class extends TextRun {
  toMarkdown(settings) {
    return `~~${this.content}~~`;
  }
};
var TextRunQuote = class extends TextRun {
  toMarkdown(settings) {
    return `>${this.content.replaceAll("\n", "\n>").slice(0, -1)}`;
  }
};
var TextRunHeading = class extends TextRun {
  toMarkdown(settings, isReply) {
    const markdown = `**${this.content}**`;
    if (isReply) {
      return `${markdown} `;
    } else {
      return `${markdown}
`;
    }
  }
};
var TextRunEmoji = class extends TextRun {
  toMarkdown(settings) {
    return `${this.content}`;
  }
};
var TextRunEdited = class extends TextRun {
  toMarkdown(settings) {
    return ` *(edited)*`;
  }
};
var TextRunCustomEmoji = class extends TextRun {
  toMarkdown(settings) {
    return `*<img src='${this.content}' style='height: var(--font-text-size)'>*`;
  }
};

// src/DiscordMessageReply.ts
var DiscordMessageReply = class {
  constructor(replyDiv) {
    if (!/^message-reply-context/.test(replyDiv.id)) {
      console.error(replyDiv);
      throw new CouldNotParseError(`Expected <div id="message-reply-context...">`);
    }
    this.header = this.constructMessageHeader(replyDiv);
    this.content = this.constructMessageContent(replyDiv);
  }
  constructMessageContent(replyDiv) {
    const messageContentElems = this.getMessageTextElems(replyDiv);
    const textRuns = [];
    for (const elem of Array.from(messageContentElems)) {
      textRuns.push(textRunFactory(elem));
    }
    return { textRuns };
  }
  /** Gets elements to be consumed by utils/textRunFactory() */
  getMessageTextElems(replyDiv) {
    var _a, _b, _c;
    let messageContentElems = (_a = replyDiv.querySelector("div[class^='repliedTextContent']")) == null ? void 0 : _a.children;
    if (!messageContentElems) {
      messageContentElems = (_b = replyDiv.querySelector("div[id^='message-content']")) == null ? void 0 : _b.children;
    }
    if (!messageContentElems) {
      messageContentElems = (_c = replyDiv.querySelector("div[class^='message-content']")) == null ? void 0 : _c.children;
    }
    if (!messageContentElems) {
      console.error("Couldn't find message content of reply: ", replyDiv);
      throw new EmptyMessageError(`Message contains no text content`);
    }
    return messageContentElems;
  }
  constructMessageHeader(replyDiv) {
    var _a;
    const nickname = (_a = replyDiv.querySelector("span[class^='username']")) == null ? void 0 : _a.textContent;
    if (!nickname) {
      console.error(replyDiv);
      throw new CouldNotParseError(`Expected a <span class='username-'> in div, but querySelector couldn't locate one`);
    }
    return { nickname };
  }
  toMarkdown(settings) {
    const markdownArray = [];
    for (const textRun of this.content.textRuns) {
      const textRunMarkdown = textRun.toMarkdown(settings, true);
      markdownArray.push(textRunMarkdown);
    }
    const textMarkdown = markdownArray.join("").replaceAll("\n", "\n>>");
    return `>**${this.header.nickname}:** ${textMarkdown}`;
  }
};

// src/DiscordMultiMessage.ts
var DiscordMultiMessage = class {
  constructor(MESSAGE_LI) {
    var _a;
    if (!((_a = MESSAGE_LI.firstElementChild) == null ? void 0 : _a.innerHTML)) {
      throw new EmptyMessageError("<li> seems to be empty");
    }
    try {
      this.header = this.constructMessageHeader(MESSAGE_LI);
    } catch (error) {
      if (!(error instanceof CouldNotParseError)) {
        throw error;
      }
    }
    this.content = this.constructMessageContent(MESSAGE_LI);
  }
  constructMessageHeader(MESSAGE_LI) {
    var _a, _b, _c;
    const headerDiv = MESSAGE_LI.querySelector("h3[class^='header']");
    if (!headerDiv) {
      throw new CouldNotParseError(`No <h3 class='header...'> found`);
    }
    const nickname = (_a = headerDiv.querySelector("span[class^='username']")) == null ? void 0 : _a.textContent;
    if (!nickname) {
      throw new CouldNotParseError(`Message Header exists, but could not find nickname`);
    }
    const timeExact = (_b = headerDiv.querySelector("time")) == null ? void 0 : _b.dateTime;
    let timeRelative = (_c = headerDiv.querySelector("time")) == null ? void 0 : _c.textContent;
    if (!(timeExact && timeRelative)) {
      throw new CouldNotParseError(`Message Header exists, but could not find time`);
    } else {
      const regexTimeRelative = /â€” (.*)/.exec(timeRelative);
      if (!(regexTimeRelative && regexTimeRelative.length == 2)) {
        throw new CouldNotParseError("Relative time could not be parsed from Regex");
      }
      timeRelative = regexTimeRelative[1];
    }
    const avatarDiv = MESSAGE_LI.querySelector("img[class^='avatar']");
    let avatarUrl = void 0;
    if (avatarDiv) {
      avatarUrl = avatarDiv.src;
    }
    const messageReplyDiv = MESSAGE_LI.querySelector("div[id^='message-reply'");
    let messageReply = void 0;
    if (messageReplyDiv) {
      messageReply = new DiscordMessageReply(messageReplyDiv);
    }
    const header = {
      nickname,
      timeExact: Date.parse(timeExact),
      timeRelative
    };
    if (avatarUrl)
      header.avatar = avatarUrl;
    if (messageReply)
      header.reply = messageReply;
    return header;
  }
  constructMessageContent(MESSAGE_LI) {
    const messageTextElems = this.getMessageTextElems(MESSAGE_LI);
    const messageAttachmentElem = MESSAGE_LI.querySelector("div[id^='message-accessories']");
    if (!messageTextElems && !messageAttachmentElem) {
      throw new EmptyMessageError(`Message contains neither text content nor attachments`);
    }
    const content = {};
    if (messageTextElems) {
      content.textRuns = [];
      for (const elem of Array.from(messageTextElems)) {
        content.textRuns.push(textRunFactory(elem));
      }
    }
    if (messageAttachmentElem) {
      content.attachments = parseMessageAttachments(messageAttachmentElem);
    }
    return content;
  }
  /** Gets elements to be consumed by utils/textRunFactory() */
  getMessageTextElems(MESSAGE_LI) {
    var _a;
    return (_a = MESSAGE_LI.querySelector("div[class^='contents'] > div[id^='message-content']")) == null ? void 0 : _a.children;
  }
  toMarkdown(settings) {
    const markdownArray = [];
    if (this.header) {
      const date = new Date(this.header.timeExact);
      markdownArray.push(
        `**${this.header.nickname} - ${date.toLocaleString()}**`
      );
      if (this.header.reply) {
        markdownArray.push(this.header.reply.toMarkdown(settings));
      }
    }
    if (this.content.textRuns) {
      const textMarkdownArray = [];
      for (const textRun of this.content.textRuns) {
        let textRunMarkdown = textRun.toMarkdown(settings);
        textRunMarkdown = textRunMarkdown.replaceAll(
          "\n",
          "\n>"
        );
        textMarkdownArray.push(textRunMarkdown);
      }
      markdownArray.push(textMarkdownArray.join(""));
    }
    if (this.content.attachments) {
      for (const url of this.content.attachments) {
        markdownArray.push(`![](${url})`);
      }
    }
    return ">" + markdownArray.join("\n>");
  }
};

// src/DiscordSingleMessage.ts
var DiscordSingleMessage = class extends DiscordMultiMessage {
  constructor(messageDiv) {
    super(messageDiv);
  }
  getMessageTextElems(messageDiv) {
    var _a;
    return (_a = messageDiv.querySelector("div[id^='message-content']")) == null ? void 0 : _a.children;
  }
};

// src/DiscordConversation.ts
var DiscordConversation = class {
  constructor(DOM, settings) {
    if (!this.isDiscordPaste(DOM)) {
      throw new CouldNotParseError("Paste doesn't appear to be from Discord");
    }
    this.messages = this.createMessages(DOM, settings);
  }
  static fromRawHTML(HTML, settings) {
    const parser = new DOMParser();
    const DOM = parser.parseFromString(HTML, "text/html");
    return new this(DOM, settings);
  }
  createMessages(DOM, settings) {
    const discordMessages = [];
    const messageElems = Array.from(DOM.querySelectorAll("li[id^='chat-messages']"));
    if (messageElems.length != 0) {
      for (const message of messageElems) {
        try {
          discordMessages.push(new DiscordMultiMessage(message));
        } catch (err) {
          if (!(err instanceof EmptyMessageError)) {
            throw err;
          } else {
            continue;
          }
        }
      }
    } else {
      discordMessages.push(new DiscordSingleMessage(DOM.body));
    }
    return discordMessages;
  }
  isDiscordPaste(DOM) {
    const messageContentElem = DOM.querySelector("div[id^='message-content']");
    if (messageContentElem) {
      if (!/message-content.\d{19}/.test(messageContentElem.id)) {
        console.error("isDiscordPaste FAIL: No <div id='message-content-\\d{19}'");
        return false;
      }
      if (!messageContentElem.className.contains("markup")) {
        console.error("isDiscordPaste FAIL: No <div class='markup...");
        return false;
      }
      if (!messageContentElem.className.contains("messageContent")) {
        console.error("isDiscordPaste FAIL: No <div class='messageContent...'");
        return false;
      }
      return true;
    }
    const messageAccesoriesElem = DOM.querySelector("div[id^='message-accessories']");
    if (messageAccesoriesElem) {
      if (!/message-accessories-\d{19}/.test(messageAccesoriesElem.id)) {
        console.error("isDiscordPaste FAIL: No <div id='message-accessories-\\d{19}'");
        return false;
      }
      if (!/container-[\w\d]{6}/.test(messageAccesoriesElem.className)) {
        console.error("isDiscordPaste FAIL: No <div class='container-\\w{6}'");
        return false;
      }
      return true;
    }
    return false;
  }
  toMarkdown(settings) {
    const markdownArray = [];
    for (const message of this.messages) {
      if (message.header && markdownArray.length > 0) {
        markdownArray.push(">");
      }
      markdownArray.push(message.toMarkdown(settings));
    }
    return markdownArray.join("\n");
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  showReplies: false,
  showEdited: true
};
var SettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl: containerElement } = this;
    containerElement.empty();
    new import_obsidian.Setting(containerElement).setName("Show replies").setDesc("If the message you're copying is a reply to another message, also copy the message it's a reply to.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showReplies).onChange(async (value) => {
        this.plugin.settings.showReplies = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerElement).setName("Show (edited)").setDesc("Copy the *(edited)* mark at the end of an edited message.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showEdited).onChange(async (value) => {
        this.plugin.settings.showEdited = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/main.ts
var DiscordFormatter = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingsTab(this.app, this));
    this.pasteMessageHandler = this.pasteMessage.bind(this);
    this.app.workspace.on("editor-paste", this.pasteMessageHandler);
  }
  onunload() {
    this.app.workspace.off("editor-paste", this.pasteMessageHandler);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    this.saveData(this.settings);
  }
  pasteMessage(event) {
    var _a;
    const rawHTML = (_a = event.clipboardData) == null ? void 0 : _a.getData("text/html");
    const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (!(rawHTML && (view == null ? void 0 : view.editor))) {
      return;
    }
    const conversation = DiscordConversation.fromRawHTML(rawHTML, this.settings);
    if (conversation.messages.length == 0) {
      return;
    }
    event.preventDefault();
    view.editor.replaceSelection(conversation.toMarkdown(this.settings));
  }
};
