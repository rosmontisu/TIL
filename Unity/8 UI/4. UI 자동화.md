- UI 를 직렬화 or public으로 하나하나 매핑하지말고.. 코드상에서 자동화해보자.
- [Reflection](obsidian://open?vault=TIL&file=Csharp%2F8.%20Reflection)이용
##### Bind함수와 Get함수를 만들어서 UI맵핑을 자동화시키자.
```cs
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SocialPlatforms.Impl;
using UnityEngine.UI;

public class UI_Button : MonoBehaviour
{
    Dictionary<Type, UnityEngine.Object[]> _objects 
        = new Dictionary<Type, UnityEngine.Object[]>();

    enum Buttons
    {
        PointButton
    }
    enum Texts
    {
        PointText,
        ScoreText
    }
    private void Start()
    {
        // UI 하나하나가 아니라 enum타입으로 넘기자(Reflection)
        // Bind함수에서 이름이 똑같은걸 찾아서 알아서 저장하도록
        // 또한, 타입을 찾을 수 있도록 Generic화 시키자 
        Bind<Button>(typeof(Buttons));
        Bind<Text>(typeof(Texts));

        // 텍스트중enums의 ScoreText의 text를 수정 테스트
        Get<Text>((int)Texts.ScoreText).text = "Bind Text";
    }

    // 딕셔너리 구조로 모든 UI를 찾아서 정리합니다.
    void Bind<T>(Type type) where T : UnityEngine.Object
    {
        // enum에 모든 요소들을 배열에 저장
        // 딕셔너리의 구조에 맞게 (Type:Object[]) 오브젝트 배열 생성
        // 딕셔너리에 추가
        string[] names = Enum.GetNames(type);
        UnityEngine.Object[] objects = new UnityEngine.Object[names.Length];
        _objects.Add(typeof(T), objects);

        // 유니티에서 드래그드롭으로 매핑하던 작업을 코드로 자동화 하자
        for (int i = 0; i < names.Length; i++)
        {
            objects[i] = Util.FindChild<T>(gameObject, names[i], true);
        }
    }

    // 딕셔너리에서 필요한 UI를 찾습니다.
    T Get<T>(int idx) where T : UnityEngine.Object
    {
        UnityEngine.Object[] objects = null;
        if (_objects.TryGetValue(typeof(T), out objects) == false)
            return null;

        return objects[idx] as T;
    }


    int _score = 0;

    public void OnButtonClicked()
    {
        Debug.Log("Button Clicked");

        _score++;
        //_text.text = $"test score : {_score}";
    }
}

```

##### GameObject를 Bind 하면 FindChild로 탐색이 불가한 문제