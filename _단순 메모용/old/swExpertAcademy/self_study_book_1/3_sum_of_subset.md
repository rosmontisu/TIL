## 3차시 대표 문제 Sum of Subset
> ### 부분 집합의 합
> 유한 개의 정수로 이루어진 집합이 있다.   
> 이 집합의 부분 집합의 합이 0이 되는 경우가 있는지 구해보라.   
>    
> 예로 { -7, -3, -2, 5, 8, } 의 집합이 있을 경우   
> { -3, -2, 5 } 의 합은 0이므로 참이다.   

위의 대표 문제를 풀기 전에 검색에 대하여 알아보자.

## 검색의 종류
- [순차 검색 (Sequential Search)](#순차-검색-sequential-search))
- [이진 검색 (Binary Search)]()
- [해싱 (Hash)]()

## 순차 검색 (Sequential Search)
#### 일렬로 되어있는 자료를 순서대로 검색하는 방법  
#### 시간 복잡도 : O(n)
- 가장 간단하고 직관적이다.   
- 배열이나 리스트 등 순차적인 자료구조에서 원하는 항목을 찾을때 유용하다.   
- 알고리즘이 단순하지만, 검색 대상이 많으면 수행시간이 급격하게 증가한다.  

## 이진 검색 (Binary Search)
#### 시간 복잡도 : O(logN)




## bookSolve 2
#### 비트 연산을 통해 문제를 간결하게 만들 수 있다.
집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 2^n개 이다.   
이는 각 원소를 부분집합에 포함O/X 2가지로 모든 원소에 적용한 경우의 수와 같다.   
   
여기서 풀이의 아이디어가 나오는데, 포함O/X를 1/0 으로 표현하면,   
비트 연산자를 이용해 부분집합들을 2진수로 표현 가능해진다.
> #### 비트 시프트 연산     
> and(&) or(|) xor(^) 보수(~)      
>      
> 비트 왼쪽 시프트    
> a << b == a * 2^b   
> 비트 오른쪽 시프트   
> a >> b == a / 2^b
   

```c
void main(void)
{
   int i, j;
   int arr[] = { -7, -3, -2, 5, 8 };
   int n = sizeof(arr) / sizeof(arr[0]);  // n:원소의 개수
   int sum;
   
   int ret = 0;
   for (i = 1; i < (1 << (n)); i++) // 1<<n : 부분 집합의 개수
   {
      sum = 0;
      for (j = 0; j < n; j++)
      {
         if (i & (i << j)) // i의 j번째 비트가 1이면 j번째 원소 출력
            sum += arr[j];
      }
      if (sum == 0)
      {
         ret = 1;
         break;
      }
   }
   printf("%s\n", ret ? "True" : "False");
}
```

